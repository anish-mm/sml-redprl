structure Ast = RedPrlAst
structure Ar = RedPrlArity
structure Vl = Ar.Vl

open Ast

structure E = RedPrlError

structure P =
struct
  open RedPrlParamData
  open RedPrlSortData
  open RedPrlParameterTerm
end

structure O = RedPrlOpData
structure CJ = RedPrlCategoricalJudgment

structure TP = TermPrinter

val ppIntInf = Fpp.text o IntInf.toString

fun makeCustom (opid, params, bindings) =
  Ast.$$ (O.POLY (O.CUST (opid, params, NONE)), bindings)

fun makeDim pos : IntInf.int -> string param =
  fn 0 => P.APP P.DIM0
   | 1 => P.APP P.DIM1
   | i => E.raiseAnnotatedError (pos, E.INVALID_DIMENSION (ppIntInf i))

structure Tac =
struct
  type binding = (string * P.param_sort) list * ast
  infix $$ $ \

  fun makeSeq mt (us : (string * P.param_sort) list) mt' =
    let
      val (syms, sorts) = ListPair.unzip us
    in
      O.MONO (O.MTAC_SEQ sorts) $$ [([],[]) \ mt, (syms,[]) \ mt']
    end

  fun multitacToTac mt =
    case out mt of
       O.MONO O.MTAC_ALL $ [_ \ t] => t
     | _ => setAnnotation (getAnnotation mt) (O.MONO O.TAC_MTAC $$ [([],[]) \ mt])

  fun tacToMultitac t =
    case out t of
       O.MONO O.TAC_MTAC $ [_ \ mt] => mt
     | _ => setAnnotation (getAnnotation t) (O.MONO O.MTAC_ALL $$ [([],[]) \ t])

  fun orElse (t1, t2) =
    multitacToTac (O.MONO O.MTAC_ORELSE $$ [([],[]) \ tacToMultitac t1, ([],[]) \ tacToMultitac t2])

  fun then_ (t1, t2) =
    multitacToTac (makeSeq (tacToMultitac t1) [] (tacToMultitac t2))

  val autoMtac = O.MONO O.MTAC_AUTO $$ []
  val autoTac = multitacToTac autoMtac

  fun exact tau m =
    O.MONO (O.RULE_EXACT tau) $$ [([],[]) \ m]

  fun exactAuto tau m =
    then_ (exact tau m, autoTac)

  fun exactDim r =
    exactAuto (O.PARAM_EXP O.DIM) (O.POLY (O.PARAM_REF (O.DIM, r)) $$ [])

  fun makeMatch (term, tau) clauses = 
    let
      fun makeClause t1 t2 = O.MONO (O.DEV_MATCH_CLAUSE tau) $$ [([],[]) \ t1, ([],[]) \ t2]
      val clauseArgs = List.map (fn (xs, (t1, t2)) => (xs,[]) \ makeClause t1 t2) clauses
      val ns = List.map (List.length o #1) clauses
    in
      O.MONO (O.DEV_MATCH (tau, ns)) $$ (([],[]) \ term) :: clauseArgs
    end
end

structure Multi =
struct
  infix $$ $ \

  val addUnderscores = List.map (fn SOME x => x | NONE => "_")

  fun makeLam [] m = m
    | makeLam (x::xs) m = O.MONO O.LAM $$ [([],[Option.getOpt (x, "_")]) \ makeLam xs m]

  fun makeApp m ns =
    List.foldl (fn (n, app) => O.MONO O.APP $$ [([],[]) \ app, ([],[]) \ n]) m ns

  fun makePathAbs [] m = m
    | makePathAbs (u::us) m = O.MONO O.PATH_ABS $$ [([Option.getOpt (u, "_")],[]) \ makePathAbs us m]

  fun makePathApp m ns =
    List.foldl (fn (r, app) => O.POLY (O.PATH_APP r) $$ [([],[]) \ app]) m ns

  fun makeNum i =
    case IntInf.compare (i, 0) of
      GREATER => O.MONO O.SUCC $$ [([],[]) \ makeNum (i - 1)]
    | EQUAL => O.MONO O.ZERO $$ []
    | LESS => O.MONO O.NEGSUCC $$ [([],[]) \ makeNum ((~ i) - 1)]

  fun flatten xsys =
    List.concat (List.map (fn (xs, y) => List.map (fn x => (x, y)) xs) xsys)

  fun makeQuant opr [] cod = cod
    | makeQuant opr ((x, a) :: doms) cod =
       O.MONO opr $$ [([],[]) \ a, ([],[Option.getOpt (x, "_")]) \ makeQuant opr doms cod]

  val makeDFun = makeQuant O.DFUN o flatten

  structure LabelSet = SplaySet (structure Elem = StringOrdered)


  fun checkNoDuplicates pos lbls =
    let
      fun insert (lbl, set) =
        if LabelSet.member set lbl then
          E.raiseAnnotatedError (pos, E.GENERIC [Fpp.text "Duplicate label", Fpp.text lbl])
        else
          LabelSet.insert set lbl
    in
      List.foldl insert LabelSet.empty lbls;
      ()
    end

  fun anonRecordLabelForIndex i =
    "proj" ^ Int.toString (i + 1)

  fun makeRecordAux pos tbs =
    let
      val fields = ListUtil.mapWithIndex (fn (_, (SOME x, ty)) => (x, ty) | (i, (NONE, ty)) => (anonRecordLabelForIndex i, ty)) (flatten tbs)
      val init = {labels = [], args = []}
      val {labels, args} =
        List.foldl
          (fn ((lbl, ty), {labels, args}) =>
            {labels = labels @ [lbl],
             args = (([],labels) \ ty) :: args})
          init
          fields

      val lbls = labels
      val _ = checkNoDuplicates pos lbls
    in
      (lbls, List.rev args)
    end

  fun makeDProd pos (tbs, ty) =
    let
      val (_, args) = makeRecordAux pos (tbs @ [([NONE], ty)])
      val lbls = ListUtil.mapWithIndex (anonRecordLabelForIndex o #1) args
    in
      O.MONO (O.RECORD lbls) $$ args
    end

  fun makeRecord pos tbs =
    let
      val (lbls, args) = makeRecordAux pos tbs
    in
      O.MONO (O.RECORD lbls) $$ args
    end

  fun makeTuple pos fields =
    let
      val (lbls, args) = ListPair.unzip fields
    in
      checkNoDuplicates pos lbls;
      O.MONO (O.TUPLE lbls) $$ List.map (fn a => ([],[]) \ a) args
    end

  fun makeAnonymousTuple terms =
    let
      val lbls = ListUtil.mapWithIndex (anonRecordLabelForIndex o #1) terms
    in
      O.MONO (O.TUPLE lbls) $$ List.map (fn a => ([],[]) \ a) terms
    end

  fun recordIntro pos fields =
    let
      val (lbls, tacs) = ListPair.unzip fields
    in
      checkNoDuplicates pos lbls;
      O.MONO (O.DEV_RECORD_INTRO lbls) $$ List.map (fn tac => ([],[]) \ tac) tacs
    end

  fun dprodIntro pos tacs =
    let
      val lbls = ListUtil.mapWithIndex (anonRecordLabelForIndex o #1) tacs
    in
      O.MONO (O.DEV_RECORD_INTRO lbls) $$ List.map (fn tac => ([],[]) \ tac) tacs
    end

end

structure Pattern =
struct
  infix $$ $ \

  (* this code is kind of crappy, feel free to improve it *)
  fun unstitchPattern (pat : 'a O.dev_pattern) : unit O.dev_pattern * 'a list =
    case pat of
       O.PAT_VAR a => (O.PAT_VAR (), [a])
     | O.PAT_TUPLE lpats =>
       let
         val (lbls, pats) = ListPair.unzip (List.map (fn (lbl, pat) => (lbl, unstitchPattern pat)) lpats)
         val (pats, names) = ListPair.unzip pats
       in
         (O.PAT_TUPLE (ListPair.zip (lbls, pats)), List.concat names)
       end

  fun makeLambda pats tac =
    let
      val (pats', namess) = ListPair.unzip (List.map unstitchPattern pats)
      val names = List.concat namess
    in
      O.MONO (O.DEV_DFUN_INTRO pats') $$ [(names, []) \ tac]
    end

  fun makeApplyHyp pat z tacs tac =
    let
      val (pat, names) = unstitchPattern pat
      val args = (List.map (fn tac => ([],[]) \ tac) tacs) @ [(names, []) \ tac]
    in
      O.POLY (O.DEV_APPLY_HYP (z, pat, List.length tacs)) $$ args
    end

  fun makeUseHyp z tacs = 
    let
      val args = List.map (fn tac => ([],[]) \ tac) tacs
    in
      O.POLY (O.DEV_USE_HYP (z, List.length tacs)) $$ args
    end

  fun makeApplyLemma pat (opid, params, subtermArgs) tacs tac =
    let
      val (pat, names) = unstitchPattern pat
      val appArgs = List.map (fn tac => ([],[]) \ tac) tacs
      val args = subtermArgs @ appArgs @ [(names, []) \ tac]
    in
      O.POLY (O.DEV_APPLY_LEMMA (opid, params, NONE, pat, List.length tacs)) $$ args
    end

  fun makeUseLemma (opid, params, subtermArgs) tacs = 
    let
      val args = List.map (fn tac => ([],[]) \ tac) tacs
    in
      O.POLY (O.DEV_USE_LEMMA (opid, params, NONE, List.length tacs)) $$ args
    end

end


%%
%header (functor RedPrlLrValsFun (structure Token : TOKEN))

%term
   EOF

 | VARNAME of string
 | OPNAME of string
 | UNDER
 | NUMERAL of IntInf.int

 | COLON
 (* delimiters *)
 | LANGLE | RANGLE
 | LANGLE_PIPE | RANGLE_PIPE
 | LPAREN | RPAREN
 | RBRACKET | LBRACKET
 | LSQUARE | RSQUARE
 (* (mostly) single-character symbols *)
 | BACK_TICK
 | COMMA
 | AMPERSAND
 | DOT
 | EQUALS
 | HASH
 | PERCENT
 | PIPE | DOUBLE_PIPE
 | QUESTION
 | SEMI
 (* arrows *)
 | SQUIGGLE_RIGHT_ARROW | SQUIGGLE_LEFT_ARROW
 | RIGHT_ARROW | LEFT_ARROW
 | DOUBLE_RIGHT_ARROW | LONG_RIGHT_ARROW
 | TRIANGLE_RIGHT

 (* parameter sorts *)
 | DIM | HYP | LVL | META_NAME
 (* sorts *)
 | EXP | TAC | TRIV | JDG

 (* keywords and symbols in parameters *)
 | LABOVE | LSUCC | LMAX

 (* keywords and symbols in expressions *)
 | AX
 | FCOM
 | BOOL | TT | FF | IF
 | WBOOL | WIF
 | NAT | ZERO | SUCC | NAT_REC
 | INT | NEGSUCC | INT_REC
 | VOID
 | S1 | BASE | LOOP | S1_REC
 | LAMBDA | DOLLAR_SIGN
 | RECORD | TIMES | TUPLE | BANG
 | PATH | ABS | AT_SIGN
 | BOX | CAP
 | UNIV
 | HCOM | COE

 (* parsing "coercions" *)
 | TACTIC

 (* keywords in tactics *)
 | CASE | OF
 | FRESH
 | LET | USE | WITH
 | THEN | ELSE
 | REFINE
 | MTAC_REC | MTAC_PROGRESS | MTAC_REPEAT | MTAC_AUTO | MTAC_HOLE
 | RULE_ID | RULE_AUTO_STEP | RULE_SYMMETRY | RULE_ELIM | RULE_HEAD_EXP | RULE_UNFOLD
 | RULE_EXACT
 | MATCH
 | QUERY | GOAL
 | PRINT

 (* keywords in judgments *)
 | TRUE | TYPE | SYNTH | AT (* `WITH` is reused *)

 | DISCRETE | KAN | CUBICAL

 (* commands and declarations *)
 | CMD_PRINT | CMD_EXTRACT
 | DCL_DEF | DCL_TAC | DCL_THM | DCL_RULE
 | BY | IN

%right LEFT_ARROW RIGHT_ARROW DOUBLE_PIPE SEMI
%right TIMES
%nonassoc COMMA AMPERSAND COLON
%nonassoc FCOM BOOL TT FF IF WBOOL WIF NAT ZERO SUCC NAT_REC INT NEGSUCC INT_REC VOID S1 BASE LOOP LAMBDA DOLLAR_SIGN PATH ABS AT_SIGN AX HCOM COE
%nonassoc HASH LANGLE LPAREN VARNAME OPNAME



%nonterm
   start of Signature.src_elt

 | ident of string
 | boundVar of string option
 | boundVars of string option list

 | psort of P.param_sort
 | psorts of P.param_sort list
 | sort of O.sort
 | sorts of O.sort list

 | bindingSig of P.param_sort list * O.sort list
 | valence of Ar.valence

   (* parameters *)
 | param of string param
 | params of string param list
 | numAsDimParam of string param
 | exclusivelyDimParam of string param
 | dimParam of string param
 | dimParams of string param list
 | numAsLevelParam of string param
 | exclusivelyLevelParam of string param
 | levelParam of string param
 | levelParams of string param list
 | typedParam of string param * P.param_sort
 | typedParams of (string param * P.param_sort) list
 | dir of string param * string param
 | backDir of string param * string param
 | equation of string param * string param
 | tube of (string param * string param) * ast abs
 | tubes of ((string param * string param) * ast abs) list

 | metavar of string
 | patvar of string * O.sort
 | patvarBindings of string list
 | customOpParams of (string param * P.param_sort option) list
 | customOpTerm of string * (string param * P.param_sort option) list * ast abs list


 | typedBinder of string option list * ast
 | typedBinders of (string option list * ast) list
 | quantifierData of (string option list * ast) list * ast
 | field of string * ast
 | fields of (string * ast) list

   (* abt abstractions *)
 | binder of string list * string list
 | binding of ast abs
 | bindings of ast abs list

   (* a type-theoretic term *)
 | monoNullaryOperator of string operator
 | polyNullaryOperator of string operator
 | regularMultinaryOperator of string operator
 | rawTermAndTac of ast (* shared with tactics *)
 | rawTerm of ast

   (* a type-theoretic term, annotated with source position *)
 | term of ast
 | terms of ast list
 | typedTerm of ast * O.sort
 | typedTerms of (ast * O.sort) list

 | atLevel of string param option
 | kind of O.K.kind
 | withKind of O.K.kind
 | kindedType of O.K.kind

 | rawJudgment of ast
 | judgment of ast

 | src_catjdg of Signature.src_catjdg
 | src_seqhyp of Signature.src_seqhyp
 | src_seqhyps of Signature.src_seqhyp list
 | src_sequent of Signature.src_sequent

 | atomicRawTac of ast
 | atomicTac of ast
 | atomicRawMultitac of ast
 | atomicMultitac of ast
 | rawMultitac of ast
 | multitac of ast
 | hypBinding of string * P.param_sort
 | hypBindings of (string * P.param_sort) list
 | rawTactic of ast
 | tactic of ast
 | tactics of ast list

 | devDecompPattern of string O.dev_pattern
 | devDecompPatterns of string O.dev_pattern list
 | tupleDecompPattern of (string * string O.dev_pattern) list
 | labeledDecompPattern of string * string O.dev_pattern
 | devAppSpine of ast list
 | bracketedDevAppSpine of ast list

 | devMatchClause of string list * (ast * ast)
 | devMatchClauses of (string list * (ast * ast)) list

 | recordFieldTactics of (string * ast) list

 | declArgument of metavariable * Ar.valence
 | declArguments of string Signature.arguments
 | declArgumentsParens of string Signature.arguments
 | declParam of string * P.param_sort
 | declParams of string Signature.params
 | declParamsBrackets of string Signature.params

   (* a declaration, annotated with source position *)
 | decl of string * Signature.src_decl * Pos.t
   (* a RedPRL signature *)
 | rawCmd of Signature.src_cmd
 | cmd of Signature.src_cmd * Pos.t
 | elt of Signature.src_elt

%verbose
%pos (string -> Coord.t)
%start start
%eop EOF DOT
%noshift EOF
%name RedPrl
%arg (fileName) : string
%%

start : elt (elt)

ident
  : OPNAME (OPNAME)
  | VARNAME (VARNAME)

boundVar
  : VARNAME (SOME VARNAME)
  | UNDER (NONE)

boundVars
  : boundVar ([boundVar])
  | boundVar boundVars (boundVar :: boundVars)

psort
  : DIM (P.DIM)
  | LVL (P.LVL)
  | HYP (P.HYP)
  | META_NAME (P.META_NAME)

psorts
  : psort ([psort])
  | psort COMMA psorts (psort :: psorts)
  | ([])

sort
  : EXP (O.EXP)
  | TAC (O.TAC)
  | TRIV (O.TRIV)
  | JDG (O.JDG)

sorts
  : sort ([sort])
  | sort COMMA sorts (sort :: sorts)
  | ([])

bindingSig
  : LBRACKET psorts RBRACKET LSQUARE sorts RSQUARE DOT (psorts, sorts)
  | LBRACKET psorts RBRACKET DOT (psorts, [])
  | LSQUARE sorts RSQUARE DOT ([], sorts)
  | ([], [])

valence
  : bindingSig sort ((bindingSig, sort))

param
  : VARNAME (P.VAR VARNAME)
  | exclusivelyDimParam (exclusivelyDimParam)
  | exclusivelyLevelParam (exclusivelyLevelParam)
  | numAsDimParam (numAsDimParam)

params
  : param ([param])
  | param params (param :: params)

numAsDimParam
  : NUMERAL (makeDim (Pos.pos (NUMERAL1left fileName) (NUMERAL1right fileName)) NUMERAL)

exclusivelyDimParam
  : LBRACKET DIM dimParam RBRACKET (dimParam)

dimParam
  : VARNAME (P.VAR VARNAME)
  | numAsDimParam (numAsDimParam)
  | exclusivelyDimParam (exclusivelyDimParam)

dimParams
  : dimParam dimParams (dimParam :: dimParams)
  | dimParam ([dimParam])

numAsLevelParam
  : NUMERAL (if NUMERAL >= 0 then P.APP (P.LCONST NUMERAL) else E.raiseAnnotatedError (Pos.pos (NUMERAL1left fileName) (NUMERAL1right fileName), E.INVALID_LEVEL (ppIntInf NUMERAL)))

exclusivelyLevelParam
  : LBRACKET LVL levelParam RBRACKET (levelParam)
  | LBRACKET LSUCC levelParam RBRACKET (P.APP (P.LABOVE (levelParam, 1)))
  | LBRACKET LABOVE levelParam NUMERAL RBRACKET (if NUMERAL >= 0 then P.APP (P.LABOVE (levelParam, NUMERAL)) else E.raiseAnnotatedError (Pos.pos (NUMERAL1left fileName) (NUMERAL1right fileName), E.INVALID_LEVEL (ppIntInf NUMERAL)))
  | LBRACKET LMAX levelParams RBRACKET (P.APP (P.LMAX levelParams))

levelParam
  : VARNAME (P.VAR VARNAME)
  | numAsLevelParam (numAsLevelParam)
  | exclusivelyLevelParam (exclusivelyLevelParam)

levelParams
  : levelParam levelParams (levelParam :: levelParams)
  | levelParam ([levelParam])

typedParam
  : VARNAME (P.VAR VARNAME, O.DIM)
  | LSQUARE VARNAME COLON psort RSQUARE (P.VAR VARNAME, psort)
  | exclusivelyDimParam (exclusivelyDimParam, O.DIM)
  | exclusivelyLevelParam (exclusivelyLevelParam, O.LVL)
  | numAsDimParam (numAsDimParam, O.DIM)

typedParams
  : typedParam ([typedParam])
  | typedParam typedParams (typedParam :: typedParams)


dir
  : param SQUIGGLE_RIGHT_ARROW param ((param1, param2))

backDir
  : param SQUIGGLE_LEFT_ARROW param ((param1, param2))

equation
  : LPAREN equation RPAREN (equation)
  | param EQUALS param (param1, param2)

tube
  : LSQUARE equation binding RSQUARE (equation, binding)

tubes
  : tube tubes (tube :: tubes)
  | ([])

metavar
  : HASH ident (ident)

customOpParams
  : params (List.map (fn x => (x, NONE)) params)

typedBinder
  : LSQUARE boundVars COLON term RSQUARE ((boundVars, term))

typedBinders
  : typedBinder ([typedBinder])
  | typedBinder typedBinders (typedBinder :: typedBinders)

quantifierData
  : typedBinder quantifierData ((typedBinder :: #1 quantifierData), #2 quantifierData)
  | term quantifierData ((([NONE], term) :: #1 quantifierData), #2 quantifierData)
  | term ([], term)

field
  : LSQUARE ident term RSQUARE (ident, term)

fields
  : field fields (field :: fields)
  | field ([field])

binder
  : LBRACKET boundVars RBRACKET LSQUARE boundVars RSQUARE (Multi.addUnderscores boundVars1, Multi.addUnderscores boundVars2)
  | LBRACKET boundVars RBRACKET (Multi.addUnderscores boundVars, [])
  | LSQUARE boundVars RSQUARE ([], Multi.addUnderscores boundVars)

binding
  : binder term (\ (binder, term))
  | term (\ (([],[]), term))

bindings
  : binding bindings (binding :: bindings)
  | binding ([binding])


(* built-in nullary operators that take no parameters *)
monoNullaryOperator
  (* axiom *)
  : AX (O.MONO O.AX)
  (* bools *)
  | BOOL (O.MONO O.BOOL)
  | TT (O.MONO O.TT)
  | FF (O.MONO O.FF)
  (* weak bools *)
  | WBOOL (O.MONO O.WBOOL)
  (* natural numbers *)
  | NAT (O.MONO O.NAT)
  | ZERO (O.MONO O.ZERO)
  (* integers *)
  | INT (O.MONO O.INT)
  (* void *)
  | VOID (O.MONO O.VOID)
  (* circle *)
  | S1 (O.MONO O.S1)
  | BASE (O.MONO O.BASE)

(* built-in nullary operators that take parameters *)
polyNullaryOperator
  (* circle *)
  : LOOP dimParam (O.POLY (O.LOOP dimParam))
  | DIM dimParam (O.POLY (O.PARAM_REF (O.DIM, dimParam)))
  | UNIV levelParam (O.POLY (O.UNIVERSE (levelParam, RedPrlKind.top)))
  | UNIV levelParam kind (O.POLY (O.UNIVERSE (levelParam, kind)))

(* built-in operators that do not have special form *)
regularMultinaryOperator
  (* bools *)
  : IF (O.MONO O.IF)
  (* weak bools *)
  | WIF (O.MONO O.WIF)
  (* natural numbers *)
  | SUCC (O.MONO O.SUCC)
  | NAT_REC (O.MONO O.NAT_REC)
  (* integers *)
  | NEGSUCC (O.MONO O.NEGSUCC)
  | INT_REC (O.MONO O.INT_REC)
  (* paths *)
  | PATH (O.MONO O.PATH_TY)
  (* equality *)
  | EQUALS (O.MONO O.EQUALITY)
  (* coe *)
  | COE LBRACKET dir RBRACKET (O.POLY (O.COE dir))

customOpTerm
  : OPNAME (OPNAME, [], [])
  | LPAREN OPNAME bindings RPAREN (OPNAME, [], bindings)
  | LBRACKET OPNAME customOpParams RBRACKET (OPNAME, customOpParams, [])
  | LPAREN LBRACKET OPNAME customOpParams RBRACKET bindings RPAREN (OPNAME, customOpParams, bindings)

patvar
  : PERCENT LSQUARE VARNAME COLON sort RSQUARE ((VARNAME, sort))
  | PERCENT VARNAME ((VARNAME, O.EXP))

patvarBindings
  : VARNAME COMMA patvarBindings (VARNAME :: patvarBindings)
  | VARNAME ([VARNAME])

rawTermAndTac
  : VARNAME (`` VARNAME)

  (* meta variable *)
  | metavar (Ast.$$# (metavar, ([], [])))
  | LPAREN metavar terms RPAREN (Ast.$$# (metavar, ([], terms)))
  | LBRACKET metavar params RBRACKET (Ast.$$# (metavar, (params, [])))
  | LPAREN LBRACKET metavar params RBRACKET terms RPAREN (Ast.$$# (metavar, (params, terms)))

  (* pattern variables *)
  | patvar (Ast.$$ (O.POLY (O.PAT_META (#1 patvar, #2 patvar, [], [])), []))
  | LPAREN patvar typedTerms RPAREN (Ast.$$ (O.POLY (O.PAT_META (#1 patvar, #2 patvar, [], List.map #2 typedTerms)), List.map (fn (tm, _) => \ (([],[]), tm)) typedTerms))
  | LBRACKET patvar typedParams RBRACKET  (Ast.$$ (O.POLY (O.PAT_META (#1 patvar, #2 patvar, typedParams, [])), []))
  | LPAREN LBRACKET patvar typedParams RBRACKET typedTerms RPAREN (Ast.$$ (O.POLY (O.PAT_META (#1 patvar, #2 patvar, typedParams, List.map #2 typedTerms)), List.map (fn (tm, _) => \ (([],[]), tm)) typedTerms))

  (* custom operators *)
  | customOpTerm (makeCustom customOpTerm)

  (* built-in operators that can be handled uniformly *)
  | monoNullaryOperator (Ast.$$ (monoNullaryOperator, []))
  | LPAREN polyNullaryOperator RPAREN (Ast.$$ (polyNullaryOperator, []))
  | LPAREN regularMultinaryOperator bindings RPAREN (Ast.$$ (regularMultinaryOperator, bindings))

  (* compositions *)
  | LPAREN FCOM LBRACKET dir RBRACKET binding tubes RPAREN
      (let val (eqs, tubes) = ListPair.unzip tubes in Ast.$$ (O.POLY (O.FCOM (dir, eqs)), (binding :: tubes)) end)
  | LPAREN BOX LBRACKET dir RBRACKET binding tubes RPAREN
      (let val (eqs, tubes) = ListPair.unzip tubes in Ast.$$ (O.POLY (O.BOX (dir, eqs)), (binding :: tubes)) end)
  | LPAREN CAP LBRACKET backDir RBRACKET binding tubes RPAREN
      (let val (eqs, tubes) = ListPair.unzip tubes in Ast.$$ (O.POLY (O.CAP (backDir, eqs)), (binding :: tubes)) end)
  | LPAREN HCOM LBRACKET dir RBRACKET binding binding tubes RPAREN
      (let val (eqs, tubes) = ListPair.unzip tubes in Ast.$$ (O.POLY (O.HCOM (dir, eqs)), (binding1 :: binding2 :: tubes)) end)

  (* numbers *)
  | NUMERAL (Multi.makeNum NUMERAL)

  (* function types *)
  | LPAREN RIGHT_ARROW quantifierData RPAREN (Multi.makeDFun (#1 quantifierData) (#2 quantifierData))
  | LPAREN LAMBDA LSQUARE boundVars RSQUARE term RPAREN (Multi.makeLam boundVars term)
  | LPAREN DOLLAR_SIGN term terms RPAREN (Multi.makeApp term terms)

  (* pair types *)
  | LPAREN TIMES quantifierData RPAREN (Multi.makeDProd (Pos.pos (LPAREN1left fileName) (RPAREN1right fileName)) quantifierData)

  (* dependent record types *)
  | RECORD (Multi.makeRecord (Pos.pos (RECORD1left fileName) (RECORD1right fileName)) [])
  | LPAREN RECORD typedBinders RPAREN (Multi.makeRecord (Pos.pos (LPAREN1left fileName) (RPAREN1right fileName)) typedBinders)
  | TUPLE (Multi.makeTuple (Pos.pos (TUPLE1left fileName) (TUPLE1right fileName)) [])
  | LPAREN TUPLE fields RPAREN (Multi.makeTuple (Pos.pos (LPAREN1left fileName) (RPAREN1right fileName)) fields)
  | LPAREN TUPLE terms RPAREN (Multi.makeAnonymousTuple terms)
  | LPAREN BANG ident term RPAREN (Ast.$$ (O.MONO (O.PROJ ident), [\ (([], []), term)]))

  (* paths *)
  | LPAREN ABS LBRACKET boundVars RBRACKET term RPAREN (Multi.makePathAbs boundVars term)
  | LPAREN AT_SIGN term dimParams RPAREN (Multi.makePathApp term dimParams)

rawTerm
  : rawTermAndTac (rawTermAndTac)
  | HASH TAC LBRACKET tactic RBRACKET (tactic)
  | HASH JDG LBRACKET judgment RBRACKET (judgment)
  (* hypotheses *)
  | COMMA LSQUARE VARNAME COLON sort RSQUARE (Ast.$$ (O.POLY (O.HYP_REF (VARNAME, sort)), []))
  | COMMA VARNAME (Ast.$$ (O.POLY (O.HYP_REF (VARNAME, O.EXP)), []))

term : rawTerm (annotate (Pos.pos (rawTerm1left fileName) (rawTerm1right fileName)) rawTerm)

terms
  : term ([term])
  | term terms (term :: terms)

typedTerm
  : LSQUARE term COLON sort RSQUARE ((term, sort))
  | term ((term, O.EXP))

typedTerms
  : typedTerm ([typedTerm])
  | typedTerm typedTerms (typedTerm :: typedTerms)

atLevel
  : AT levelParam (SOME levelParam)
  | (NONE)

kind
  : DISCRETE (O.K.DISCRETE)
  | KAN (O.K.KAN)
  | HCOM (O.K.HCOM)
  | COE (O.K.COE)
  | CUBICAL (O.K.CUBICAL)

withKind
  : WITH kind (kind)
  | (O.K.top)

kindedType
  : kind TYPE (kind)
  | TYPE (O.K.top)

rawJudgment
  : term EQUALS term IN term atLevel withKind (Ast.$$ (O.POLY (O.JDG_EQ (atLevel, withKind)), [\ (([],[]), term1), \ (([],[]), term2), \ (([],[]), term3)]))
  | term IN term atLevel withKind (Ast.$$ (O.POLY (O.JDG_EQ (atLevel, withKind)), [\ (([],[]), term1), \ (([],[]), term1), \ (([],[]), term2)]))
  | term TRUE atLevel withKind (Ast.$$ (O.POLY (O.JDG_TRUE (atLevel, withKind)), [\ (([],[]), term)]))
  | term atLevel withKind (Ast.$$ (O.POLY (O.JDG_TRUE (atLevel, withKind)), [\ (([],[]), term)]))
  | term EQUALS term atLevel kindedType (Ast.$$ (O.POLY (O.JDG_EQ_TYPE (atLevel, kindedType)), [\ (([],[]), term1), \ (([],[]), term2)]))
  | term kindedType atLevel (Ast.$$ (O.POLY (O.JDG_EQ_TYPE (atLevel, kindedType)), [\ (([],[]), term), \ (([],[]), term)]))
  | term SYNTH atLevel withKind (Ast.$$ (O.POLY (O.JDG_SYNTH (atLevel, withKind)), [\ (([],[]), term)]))

judgment : rawJudgment (annotate (Pos.pos (rawJudgment1left fileName) (rawJudgment1right fileName)) rawJudgment)

src_catjdg : rawJudgment (CJ.astOut rawJudgment)

src_seqhyp
  : VARNAME COLON src_catjdg ((VARNAME, src_catjdg))
  | UNDER COLON src_catjdg (("_", src_catjdg))
  | src_catjdg (("_", src_catjdg))

src_seqhyps
  : src_seqhyp ([src_seqhyp])
  | src_seqhyp COMMA src_seqhyps (src_seqhyp :: src_seqhyps)
  | ([])

src_sequent
  : src_catjdg ([], src_catjdg)
  | src_seqhyps RANGLE RANGLE src_catjdg (src_seqhyps, src_catjdg)

recordFieldTactics
   : VARNAME EQUALS tactic COMMA recordFieldTactics ((VARNAME, tactic) :: recordFieldTactics)
   | VARNAME EQUALS tactic ([(VARNAME, tactic)])
   | ([])

devAppSpine
  : tactic COMMA devAppSpine (tactic :: devAppSpine)
  | tactic ([tactic])
  | ([])

bracketedDevAppSpine
  : LSQUARE devAppSpine RSQUARE (devAppSpine)
  | ([])

devDecompPattern
  : VARNAME (O.PAT_VAR VARNAME)
  | LANGLE tupleDecompPattern RANGLE (O.PAT_TUPLE tupleDecompPattern)

devDecompPatterns
  : devDecompPattern COMMA devDecompPatterns (devDecompPattern :: devDecompPatterns)
  | devDecompPattern ([devDecompPattern])

labeledDecompPattern
  : VARNAME EQUALS devDecompPattern (VARNAME, devDecompPattern)
  | VARNAME (VARNAME, O.PAT_VAR VARNAME)

tupleDecompPattern
   : labeledDecompPattern COMMA tupleDecompPattern (labeledDecompPattern :: tupleDecompPattern)
   | labeledDecompPattern ([labeledDecompPattern])
   | ([])

devMatchClause
  : LSQUARE patvarBindings PIPE term DOUBLE_RIGHT_ARROW tactic RSQUARE (patvarBindings, (term, tactic))
  | LSQUARE term DOUBLE_RIGHT_ARROW tactic RSQUARE ([], (term, tactic))

devMatchClauses
  : devMatchClause devMatchClauses (devMatchClause :: devMatchClauses)
  | ([])

atomicRawTac
  : REFINE VARNAME (Ast.$$ (O.MONO (O.RULE_PRIM VARNAME), []))
  | RULE_ID (Ast.$$ (O.MONO O.RULE_ID, []))
  | RULE_AUTO_STEP (Ast.$$ (O.MONO O.RULE_AUTO_STEP, []))
  | RULE_SYMMETRY (Ast.$$ (O.MONO O.RULE_SYMMETRY, []))
  | RULE_ELIM VARNAME (Ast.$$ (O.POLY (O.RULE_ELIM VARNAME), []))
  | RULE_UNFOLD OPNAME (Ast.$$ (O.POLY (O.RULE_UNFOLD OPNAME), []))
  | BACK_TICK term (Tac.exactAuto O.EXP term)
  | RULE_EXACT term (Tac.exact O.EXP term)
  | AT_SIGN dimParam (Tac.exactDim dimParam)
  | RULE_HEAD_EXP (Ast.$$ (O.MONO O.RULE_HEAD_EXP, []))

  | atomicTac DOUBLE_PIPE tactic %prec DOUBLE_PIPE (Tac.orElse (atomicTac, tactic))
  | LANGLE_PIPE multitac RANGLE_PIPE (Tac.multitacToTac multitac)

  | LAMBDA devDecompPatterns DOT tactic (Pattern.makeLambda devDecompPatterns tactic)
  | LANGLE boundVars RANGLE tactic (Ast.$$ (O.MONO (O.DEV_PATH_INTRO (List.length boundVars)), [\ ((Multi.addUnderscores boundVars, []), tactic)]))
  | LANGLE recordFieldTactics RANGLE (Multi.recordIntro (Pos.pos (LANGLE1left fileName) (RANGLE1right fileName)) recordFieldTactics)
  | IF VARNAME THEN tactic ELSE tactic
      (Ast.$$ (O.POLY (O.DEV_BOOL_ELIM VARNAME), [\ (([],[]), tactic1), \ (([],[]), tactic2)]))

   | LET VARNAME COLON LSQUARE judgment RSQUARE EQUALS tactic DOT tactic
      (Ast.$$ (O.MONO O.DEV_LET, [\ (([],[]), judgment), \ (([],[]), tactic1), \(([VARNAME],[]), tactic2)]))

  | LET devDecompPattern EQUALS VARNAME bracketedDevAppSpine DOT tactic
      (Pattern.makeApplyHyp devDecompPattern VARNAME bracketedDevAppSpine tactic)

  | LET devDecompPattern EQUALS customOpTerm bracketedDevAppSpine DOT tactic (Pattern.makeApplyLemma devDecompPattern customOpTerm bracketedDevAppSpine tactic)

  | USE VARNAME bracketedDevAppSpine (Pattern.makeUseHyp VARNAME bracketedDevAppSpine)
  | USE customOpTerm bracketedDevAppSpine (Pattern.makeUseLemma customOpTerm bracketedDevAppSpine)

  | CASE VARNAME OF BASE DOUBLE_RIGHT_ARROW tactic PIPE LOOP VARNAME DOUBLE_RIGHT_ARROW tactic
      (Ast.$$ (O.POLY (O.DEV_S1_ELIM VARNAME1), [\ (([],[]), tactic1), \(([VARNAME2], []), tactic2)]))

  | MATCH typedTerm LBRACKET devMatchClauses RBRACKET (Tac.makeMatch typedTerm devMatchClauses)
  | QUERY VARNAME LEFT_ARROW GOAL DOT tactic (Ast.$$ (O.MONO O.DEV_QUERY_GOAL, [\ (([],[VARNAME]), tactic)]))
  | PRINT typedTerm (Ast.$$ (O.MONO (O.DEV_PRINT (#2 typedTerm)), [\ (([], []), #1 typedTerm)]))

  (* overlapping with term *)
  | rawTermAndTac (rawTermAndTac)

atomicTac : atomicRawTac (annotate (Pos.pos (atomicRawTac1left fileName) (atomicRawTac1right fileName)) atomicRawTac)

atomicRawMultitac
  : LSQUARE tactics RSQUARE (Ast.$$ (O.MONO (O.MTAC_EACH (List.length tactics)), List.map (fn t => \ (([],[]), t)) tactics))
  | HASH NUMERAL LBRACKET tactic RBRACKET (Ast.$$ (O.MONO (O.MTAC_FOCUS (IntInf.toInt NUMERAL)), [\ (([],[]), tactic)]))
  | MTAC_REPEAT LBRACKET multitac RBRACKET (Ast.$$ (O.MONO O.MTAC_REPEAT, [\ (([], []), multitac)]))
  | MTAC_AUTO (Tac.autoMtac)
  | MTAC_PROGRESS LBRACKET multitac RBRACKET (Ast.$$ (O.MONO O.MTAC_PROGRESS, [\ (([], []), multitac)]))
  | MTAC_REC VARNAME IN LBRACKET multitac RBRACKET (Ast.$$ (O.MONO O.MTAC_REC, [\ (([],[VARNAME]), multitac)]))
  | LBRACKET multitac RBRACKET (multitac)
  | FRESH hypBindings RIGHT_ARROW atomicRawMultitac SEMI multitac %prec LEFT_ARROW (Tac.makeSeq atomicRawMultitac hypBindings multitac)
  | atomicTac %prec SEMI (Ast.$$ (O.MONO O.MTAC_ALL, [\ (([],[]), atomicTac)]))
  | QUESTION ident (Ast.$$ (O.MONO (O.MTAC_HOLE (SOME ident)), []))
  | QUESTION (Ast.$$ (O.MONO (O.MTAC_HOLE NONE), []))

atomicMultitac
  : atomicRawMultitac (annotate (Pos.pos (atomicRawMultitac1left fileName) (atomicRawMultitac1right fileName)) atomicRawMultitac)

rawMultitac
  : multitac SEMI atomicMultitac %prec SEMI (Tac.makeSeq multitac [] atomicMultitac)
  | atomicMultitac %prec SEMI (atomicMultitac)

multitac : rawMultitac (annotate (Pos.pos (rawMultitac1left fileName) (rawMultitac1right fileName)) rawMultitac)

hypBinding
  : VARNAME COLON psort (VARNAME, psort)
  | UNDER COLON psort ("_", psort)
  | VARNAME (VARNAME, P.HYP)
  | UNDER ("_", P.HYP)

hypBindings
  : hypBinding ([hypBinding])
  | hypBinding COMMA hypBindings %prec COMMA (hypBinding :: hypBindings)
  | ([])

rawTactic
  : multitac %prec SEMI (Tac.multitacToTac multitac)

tactic
  : rawTactic (annotate (Pos.pos (rawTactic1left fileName) (rawTactic1right fileName)) rawTactic)

tactics
  : tactic ([tactic])
  | tactic COMMA tactics (tactic :: tactics)

declArgument
  : metavar COLON valence ((metavar, valence))
  | metavar ((metavar, (([],[]), O.EXP)))

declArguments
  : declArgument ([declArgument])
  | declArgument SEMI declArguments (declArgument :: declArguments)
  | ([])

declArgumentsParens
  : LPAREN declArguments RPAREN (declArguments)
  | ([])

declParam
  : VARNAME COLON psort (VARNAME, psort)

declParams
  : declParam ([declParam])
  | declParam COMMA declParams (declParam :: declParams)
  | ([])

declParamsBrackets
  : LBRACKET declParams RBRACKET (declParams)
  | ([])

decl
  : DCL_DEF OPNAME declParamsBrackets declArgumentsParens COLON sort EQUALS LSQUARE term RSQUARE
      (OPNAME, Signature.DEF {arguments = declArgumentsParens, params = declParamsBrackets, definiens = term, sort = sort}, Pos.pos (OPNAMEleft fileName) (OPNAMEright fileName))
  | DCL_DEF OPNAME declParamsBrackets declArgumentsParens EQUALS LSQUARE term RSQUARE
      (OPNAME, Signature.DEF {arguments = declArgumentsParens, params = declParamsBrackets, definiens = term, sort = O.EXP}, Pos.pos (OPNAMEleft fileName) (OPNAMEright fileName))
  | DCL_TAC OPNAME declParamsBrackets declArgumentsParens EQUALS LSQUARE tactic RSQUARE
      (OPNAME, Signature.TAC {arguments = declArgumentsParens, params = declParamsBrackets, script = tactic}, Pos.pos (OPNAMEleft fileName) (OPNAMEright fileName))
  | DCL_THM OPNAME declParamsBrackets declArgumentsParens COLON LSQUARE src_sequent RSQUARE BY LSQUARE tactic RSQUARE
      (OPNAME, Signature.THM {arguments = declArgumentsParens, params = declParamsBrackets, goal = src_sequent, script = tactic}, Pos.pos (OPNAMEleft fileName) (OPNAMEright fileName))

rawCmd
  : CMD_PRINT OPNAME (Signature.PRINT OPNAME)
  | CMD_EXTRACT OPNAME (Signature.EXTRACT OPNAME)

cmd : rawCmd (rawCmd, (Pos.pos (rawCmd1left fileName) (rawCmd1right fileName)))

elt
  : cmd (Signature.CMD cmd)
  | decl (Signature.DECL decl)
